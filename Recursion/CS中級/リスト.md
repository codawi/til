たくさんの場面で、例えばクラスメートや高速道路で走っている車、ショッピングカートに入っている商品や買い物リストなど、複数のデータを扱う必要があります。そのときに、データを順序通りにまとめて保管できるのが**リスト**（list）という構造です。

リストは、データを順番に並べて保管するための仕組みで、その中に入っている値には番号（インデックス）が割り当てられています。たとえば、名前のリストがある場合、インデックスを使用してリストから特定の名前を取得したり、スライシングを使用して名前の範囲を取得したりすることができます。

例えば、リスト構造の例として、文字列を見てみましょう。文字列は文字の並びであり、リストの一種です。文字列内の各文字は、文字列内の特定の位置、つまりインデックスを持っており、インデックスを使用して文字列内の個々の文字や文字のグループにアクセスすることができました。

## 配列

**配列**（array）は、連続したメモリにそれぞれの要素を格納するデータ構造です。要素は通常、連続した形で保存され、各要素はメモリ内の特定の場所を占めます。各要素のメモリ上の位置は、各データのサイズと配列内の項目のインデックスに基づく簡単な数式で計算できるため、配列内の特定の項目に高速にアクセスすることができます。

コンピュータのメモリでは、一つ一つのメモリアドレスがメモリ上の 1 バイトを指しています。例えば、0x7FFE23B3E88C というメモリアドレスは、コンピュータのメモリ上の 1 バイトを直接指すことになります。

データが「連続して」格納されているということは、例えば 0x034FD32 のメモリアドレスが指すところにデータ値が格納されている場合、次のデータ値は 0x034FD33 のメモリアドレスに格納され、その次の値はメモリアドレス 0x034FD34 に格納されます。

ただし、データ型によって必要とするバイト数は仕様によって異なります。例えば、32 ビットの int データ型であれば、格納される値ごとに 4 バイトが必要になります。したがって、最初の int データがメモリアドレス 0x63FE44 に格納されると、次の int データがメモリアドレス 0x63FE48 に格納され、その次の int データがメモリアドレス 0x63FE4C などに格納されます。

格納されている要素数に応じて、必要に応じて自動的に大きくしたり小さくしたりできるデータ構造として**動的配列**（dynamic array）が挙げられます。

動的配列は、新しい要素を追加するときに既存のメモリスペースが不足している場合、自動的により大きなメモリブロックを確保します。そして、既存の要素を新しいメモリブロックにコピーします。この機能により、配列は効率的に大量の要素を取り扱うことが可能です。

一方、動的配列において要素が削除されるとき、実際には要素がメモリから物理的に削除されるわけではないことが一般的です。代わりに、配列の論理サイズ（要素数）がデクリメント（減少）され、要素が削除された場所は空きスペースとなります。この空きスペースは、新たに要素が追加される際に再利用されます。

動的配列には、固定サイズ配列と比較していくつかの利点があります。主な利点のひとつは、配列のサイズや占有するメモリの量を気にすることなく、要素の保存やアクセスを効率的に行うことができる点です。また、配列のデータを操作するためのさまざまなメソッドや演算子が用意されており、要素の挿入や削除、検索などを行うことができます。

**固定長配列と動的配列**

多くのプログラミング言語では、固定長配列には、要素を挿入、削除、サイズ変更するためのメソッドが組み込まれていません。これは、固定サイズ配列は、作成時に長さが決まっており、後から変更することができないからです。

一方、動的配列はサイズ変更が可能なように設計されており、配列データを操作するためのさまざまなメソッドが用意されています。これらのメソッドにより、要素の挿入や削除、特定の要素の検索など、配列に対する操作を行うことができます。

例えば、Python のリスト型は、要素の挿入や削除を行う append(), insert(), pop(), remove() などのメソッドと、要素を検索する index() メソッドを提供しています。C++ では、vector クラスが、push_back(), insert(), pop_back(), erase() などの同様のメソッドを提供しています。

動的配列の要素の追加、削除に必要な時間計算量を考えてみましょう。以降、動的配列の論理サイズ、容量を次のように表します。

- L : 論理サイズ
- C : 容量

### **1-1. 先頭への挿入**

動的配列の先頭に要素を挿入するには、通常、既存のすべての要素を 1 つずつずらして、新しい要素のためのスペースを確保する必要があります。これは特に配列が大きい場合には、時間のかかる操作となります。n 個の要素がある場合、n 個の要素を移動させる必要があるため、結果として O(n) の計算コストが必要になります。動的配列の一番最初の要素にいきなり値を追加できないのは、すでにセルの中に値が存在していており、値を上書きしてしまうからです。

**Note: イメージ**

```php
// [32,34,23,3,10]、L=5, C=10 に 20 を先頭に挿入します
[32,34,23,3,10,null,null,null,null,null]
[32,34,23,3,10,20] // L=6、C=10、O(1)
[32,34,23,3,20,10] // L=6、C=10、O(1)
[32,34,23,20,3,10] // L=6、C=10、O(1)
[32,34,20,23,3,10] // L=6、C=10、O(1)
[32,20,34,23,3,10] // L=6、C=10、O(1)
[20,32,34,23,3,10] // L=6、C=10、O(1)
```

**Note: 値のコピー**

スロットに値をコピーするとは、メモリの中にあるセルの中に、値をコピーし格納することを指します。例えば、JavaScript では以下のような処理が行われています。

```php
let copyValue = array[1];
array[1] = array[0];
array[0] = copyValue;
```

要素を 1 つ隣に移動するのに 3 回の計算が必要となるので、n 個の要素を移動するには 3n (= O(n)) 回の計算が必要になります。

### **1-2. 先頭の削除**

一方、先頭の要素を削除する場合は、n-1 個の要素を 1 スロット後ろ方向に移動させる必要があるため、O(n) の計算コストが必要になります。

**Note: イメージ**

```php
// [34,32,23,3,10]、L=5、C=10、34 を先頭から取り除きます
[32,34,23,3,10] // L=5、C=10、O(1)
[32,23,34,3,10] // L=5、C=10、O(1)
[32,23,3,34,10] // L=5、C=10、O(1)
[32,23,3,10,34] // L=5、C=10、O(1)
[32,23,3,10,null] // L=4、C=10、O(1)
```

**Note: 注意**

動的配列は、データ構造として固定長配列を使用して実装され、要素の追加や削除によって論理配列のサイズを変更する機能を提供します。しかし、この操作では、実際に固定長配列から要素を追加したり削除したりすることはありません。その代わり、必要なサイズの新しい配列を作成し、関連する要素を古い配列から新しい配列にコピーします。

動的配列に要素を追加する場合、配列の実装は通常、新しい要素を格納するのに十分な容量があるかどうかをチェックします。十分な容量がある場合は、単に配列の論理サイズを増加させ、次の使用可能なインデックスに新しい要素を格納します。もし十分な容量がない場合は、より大きな容量の新しい配列を作成し、古い要素と新しい要素を新しい配列にコピーします。

同様に、動的配列から要素を削除すると、配列の実装は単に配列の論理サイズをデクリメントし、削除された要素が残したギャップを埋めるために残りの要素を移動させることがあります。しかし、実際の要素は、その下にある固定サイズの配列から削除されるわけではありません。

### **2-1. 途中への挿入**

n 個の要素の動的配列の真ん中へ要素の挿入を行う場合、先ほど学習した先頭に要素を挿入する場合と同様の処理を配列の真ん中まで行えば良いことになります。したがって、0.5n 個の要素を移動させる必要があり、結果として O(n) の計算コストが必要になります。

**Note: イメージ**

```php
// [32,34,23,3]、L=4、C=10、20 を真ん中に挿入します
[32,34,23,3,null,null,null,null]
[32,34,23,3,20] // L=5、C=10、O(1)
[32,34,23,20,3] // L=5、C=10、O(1)
[32,34,20,23,3] // L=5、C=10、O(1)
```

### **2-2. 途中の削除**

一方、動的配列の真ん中から要素を削除する場合、0.5n - 1 回の移動が必要となるので、同様に O(n) の計算コストが必要になります。

**Note: イメージ**

```php
// [34,32,23,3,10]、L=5、C=10、23 を真ん中から取り除きます
[34,32,3,23,10] // L=5、C=10、O(1)
[34,32,3,10,23] // L=5、C=10、O(1)
[34,32,3,10,null] // L=5、C=10、O(1)
```

### **3-1. 末端への挿入**

配列の末端に要素を挿入する処理は、先述した通り、配列の論理サイズと収容可能サイズとの兼ね合いで妥当な処理が実行されます。配列の容量が最大に達している、つまり「論理サイズ = 収容可能サイズ」の場合、新しい配列を作成し、もとの配列に入っていた n 個のデータと新しく追加したデータを合わせた計 n+1 個の要素を、その新しい配列にコピーします。したがって、O(n) の計算コストが必要になります。

しかし、ほとんどのケースでは、配列に余裕があるので、最後のスロットにデータを挿入するだけで済みます。この場合は、計算コストが O(1) となります。

**Note: イメージ**

```php
[1,2,3,4,null,null,null,null] // C=8、L=4、O(1)
[1,2,3,4,5] // C=8、L=5、O(1)
[1,2,3,4,5,6] // C=8、L=6、O(1)
[1,2,3,4,5,6,7] // C=8、L=7、O(1)
[1,2,3,4,5,6,7,8] // C=8、L=8、O(1)

// C=L となったとき、それ以上要素を追加することができないので、新しい配列を作成し、そこに n+1 個の要素をコピーします
[1,2,3,4,5,6,7,8,9] // C=16、L=9、O(9)
```

このように、コンピュータは複数の要素を一気に追加することができず、ステップバイステップでしか処理を行うことができないため、時間計算量や空間計算量を常に意識する必要がある点に注意しましょう。

収容可能サイズが n の空の配列に対して、n+1 個の要素を挿入する時、最初の n 回はまだ値が入っていない部分に挿入するだけなので、それぞれ O(1) の計算コストがかかり、最後の n+1 個目の値の挿入のみ、配列の要領を超えてしまうので、新しい配列を作成し、n+1 個の要素をその配列にコピーします。ここで平均を求めると、

$$
n∗O(1)+O(n)n+1=2nn+1≒O(1)
$$

のようになります。したがって、最後に要素を挿入する操作の償却計算量は O(1) になります。この場合、1/nの確率で最悪計算量 O(n) が発生します。

### **3-2. 末端の削除**

配列の末尾から要素を削除するのは簡単で、単純に O(1) の計算量が発生します。

**Note: イメージ**

```php
[1,2,3,4,5,6,7,8] // C=16、L=8
[1,2,3,4,5,6,7,null] // C=16、L=7、O(1)
```

## 二次元配列

データの「列」を扱うには、int 型、double 型、str 型、オブジェクトのリストなどを格納する配列を利用しました。では、データの「表」の扱い方について見ていきましょう。

学校の教室にいるそれぞれの生徒を調べるようなソフトウェアを作成するケースを考えてみましょう。1 年 A 組、1 年 B 組のように複数のクラスが存在し、それぞれのクラスが生徒を持つような配列を作成する必要があるでしょう。

```php
school = [class1, class2, class3, ...., classM]
classK = [student1, student2, student3, ..., studentN]
```

学校に各クラスが含まれているので、以下のように表せます。

```php
school = [
   class1, class2, class3, class4, .. ,
]
```

1 つ 1 つのクラスは、複数の生徒によって構成される配列なので、

```php
school = [
   [student1, student2, student3, student4], 
   [student11, student12, student13, student14], 
   [student21, student22, student23, student24], 
]
```

のように配列の中に配列を入れることで表現することができます。例えば、school[1] とすれば、class2 にアクセスすることができます。

```php
school[1]
// [student11, student12, student13, student14]
```

また、school[1][2] とすれば、class1 の中の student13 にアクセスすることができます。

```php
school[1][2]
// student13
```

二次元配列は表として表現することができ、配列の各要素は表の行、その要素内の各値は表の列となります。例えば、次のような二次元配列を考えてみましょう。

```php
[
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
```

この配列は、3 行 3 列の表として表現することができます。

二次元配列や後述する多次元配列を使えば、データのアクセスやメンテナンスが簡単になります。上記の例のように、学校の教室にいるそれぞれの生徒を調べるような場合を考えてみましょう。

1 次元配列によって全生徒を格納する方法では、アクセスする際にどのクラスの何番目の生徒かを探すのが非常に困難になります。もし仮に、クラス毎に生徒の配列を作成し変数に代入する場合、変数を作成するたびに、特定のリソースが必要となり、アクセスする際にはそれを探す必要があります。

二次元の要素を取り出すには、array[i][j] のようにインデックス演算子を 2 回使う必要があるため、二次元配列の中から特定の要素を検索する場合、反復処理を行います。array[i]とは、二次元配列の中にある i 番目の配列を指し、[j] 演算子はその i 番目の配列の中の、インデックス j の要素を返します。

### **二次元固定配列のサイズ**

一方、二次元固定配列の場合、配列のサイズが固定されているのでメモリ上に連続して格納することができます。例えば、m × n の 二次元固定長配列の副配列に x バイトのデータ型の要素が n 個含まれていた場合、この二次元固定配列が使用するメモリの総量は m × n × x になります。

例えば、3 行 10 列の 2 次元固定長配列で、各要素が int 型（多くのシステムでは通常 4 バイト）であれば、メモリ上の配列の総サイズは 3 × 10 × 4 = 120 バイトになります。

したがって、各要素が x バイトの m x n の二次元固定長配列 A の 要素 A[i][j] の参照は次のように計算することができます。

A[i][j] のメモリアドレス

= A の初期アドレス + (i × n × x) + (j × x)

### **ラウンドロビンアルゴリズム**

整数によって構成される複数のバック bag1, bag2, bag3, ... bagN と自然数 n が与えられるので、それぞれのバックから順番に 1 つずつ合計 n 個分の数字を取り出すアルゴリズムを 二次元配列を使って考えてみましょう。

ラウンドロビンとは、集合の中の各項目を順番に処理させるスケジューリングアルゴリズムです。

例えば、ラウンドロビンを使って数字を取り出すには、まず bag1 から最初の数字を選び、次に bag2 から最初の数字を選び、すべての袋が処理されるまでこれを繰り返すアルゴリズムを実装します。次に、各袋の 2 番目の数字を選択し、合計で n 個の数字が取得されるまでこの処理を続けます。例えば、bag1 に 1,2,3、bag 2 に 4, 5, 6、bag3 に 7, 8, 9 が入っていて、n を 6 とした場合、1, 4, 7, 2, 5, 8 の順番で取り出すことになります。

今回は各袋の最初の数字から取り出していくのではなく、ランダムな数字を取り出していきます。

```php
<?php
function printArray($intArr){
    echo "[";
    for ($i = 0; $i < count($intArr); $i++){
        echo $intArr[$i] . " ";
    }
    echo "]" . PHP_EOL;
}

# 鞄の中から選ぶには、ラウンドロビンというやり方を使いましょう。ラウンドロビンとは、1つずつ周回して、終わったら最初からやり直すという意味です。
# 4つのバッグがある場合, bag1 -> bag2 -> bag3 -> bag4 -> bag1 -> bag2...のような処理が行われます。

function chooseNFromBags2d($n, $listOfBags){
    $totalBags = count($listOfBags);
    $chosenNumbers = [];
    $counter = 0;
    while($counter < $n){
        # counter % numberOfBags によって、ラウンドロビンができます。バッグの中を循環します。
        $currentBag = $listOfBags[$counter % $totalBags];
        # 選択された数値を追加します。currentBagからランダムな値が選択されます。
        $chosenNumbers[] = ($currentBag[rand(0, count($currentBag) - 1)]);
        # counterを1ずつ増加します。
        $counter+=1;
    }
    return $chosenNumbers;
}

# それぞれのバッグは4つの数字を含んでいます。
# 二次元配列
$luckyArrayOfBags = [[21,5,12,25],[100,88,354,643],[122,145,825,4],[228,674,777,77]];

printArray(chooseNFromBags2d(10, $luckyArrayOfBags));
```

# **多次元配列**

---

配列の配列が可能であるように、配列の配列のまた更なる配列といった多次元にわたる配列も表現することができます。現実世界で入れ子構造になっているものはなんでも多次元配列を適用することができます。

入れ子構造は日常にあふれています。例えば次のようなものがあります。

住所：国 > 都道府県 > 市区町村 > 字 > 番地・号

みなさんの家は、なんらかの番地・号に含まれており、各番地・号は字に含まれています。さらに各字は市区町村に、各市区町村は都道府県に、その各都道府県も国に含まれるというような入れ子構造によって住所は記述されるのです。

倉庫の中にある製品 ：倉庫番号 > セクション > 通路 > 階層 > 分類

動物の分類：目 > 科 > 属 > 種

生徒 ：学校 > クラス > 出席番号

多次元配列は、メモリの仕組みも含めて、二次元配列と同じように動作します。次元は、入れ子になった配列が何個存在するかを表し、ランクとも呼ばれます。多次元配列の要素を取得する際は、ランクと同じ回数だけインデックス操作が必要になります。

例えば、上記の動物の分類

目 > 科 > 属 > 種

について見てみましょう。

この例を表現するには 4 次元の配列が必要です。ランク 4 なので、目的となる動物を取得するには以下のように 4 つのインデックス演算子による呼び出しが必要です。最も深い階層に存在する要素を取得するには、animals[orderId][familyId][genusId][speciesId] でアクセスします。
