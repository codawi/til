たくさんの場面で、例えばクラスメートや高速道路で走っている車、ショッピングカートに入っている商品や買い物リストなど、複数のデータを扱う必要があります。そのときに、データを順序通りにまとめて保管できるのが**リスト**（list）という構造です。

リストは、データを順番に並べて保管するための仕組みで、その中に入っている値には番号（インデックス）が割り当てられています。たとえば、名前のリストがある場合、インデックスを使用してリストから特定の名前を取得したり、スライシングを使用して名前の範囲を取得したりすることができます。

例えば、リスト構造の例として、文字列を見てみましょう。文字列は文字の並びであり、リストの一種です。文字列内の各文字は、文字列内の特定の位置、つまりインデックスを持っており、インデックスを使用して文字列内の個々の文字や文字のグループにアクセスすることができました。

## 配列

**配列**（array）は、連続したメモリにそれぞれの要素を格納するデータ構造です。要素は通常、連続した形で保存され、各要素はメモリ内の特定の場所を占めます。各要素のメモリ上の位置は、各データのサイズと配列内の項目のインデックスに基づく簡単な数式で計算できるため、配列内の特定の項目に高速にアクセスすることができます。

コンピュータのメモリでは、一つ一つのメモリアドレスがメモリ上の 1 バイトを指しています。例えば、0x7FFE23B3E88C というメモリアドレスは、コンピュータのメモリ上の 1 バイトを直接指すことになります。

データが「連続して」格納されているということは、例えば 0x034FD32 のメモリアドレスが指すところにデータ値が格納されている場合、次のデータ値は 0x034FD33 のメモリアドレスに格納され、その次の値はメモリアドレス 0x034FD34 に格納されます。

ただし、データ型によって必要とするバイト数は仕様によって異なります。例えば、32 ビットの int データ型であれば、格納される値ごとに 4 バイトが必要になります。したがって、最初の int データがメモリアドレス 0x63FE44 に格納されると、次の int データがメモリアドレス 0x63FE48 に格納され、その次の int データがメモリアドレス 0x63FE4C などに格納されます。

格納されている要素数に応じて、必要に応じて自動的に大きくしたり小さくしたりできるデータ構造として**動的配列**（dynamic array）が挙げられます。

動的配列は、新しい要素を追加するときに既存のメモリスペースが不足している場合、自動的により大きなメモリブロックを確保します。そして、既存の要素を新しいメモリブロックにコピーします。この機能により、配列は効率的に大量の要素を取り扱うことが可能です。

一方、動的配列において要素が削除されるとき、実際には要素がメモリから物理的に削除されるわけではないことが一般的です。代わりに、配列の論理サイズ（要素数）がデクリメント（減少）され、要素が削除された場所は空きスペースとなります。この空きスペースは、新たに要素が追加される際に再利用されます。

動的配列には、固定サイズ配列と比較していくつかの利点があります。主な利点のひとつは、配列のサイズや占有するメモリの量を気にすることなく、要素の保存やアクセスを効率的に行うことができる点です。また、配列のデータを操作するためのさまざまなメソッドや演算子が用意されており、要素の挿入や削除、検索などを行うことができます。

**固定長配列と動的配列**

多くのプログラミング言語では、固定長配列には、要素を挿入、削除、サイズ変更するためのメソッドが組み込まれていません。これは、固定サイズ配列は、作成時に長さが決まっており、後から変更することができないからです。

一方、動的配列はサイズ変更が可能なように設計されており、配列データを操作するためのさまざまなメソッドが用意されています。これらのメソッドにより、要素の挿入や削除、特定の要素の検索など、配列に対する操作を行うことができます。

例えば、Python のリスト型は、要素の挿入や削除を行う append(), insert(), pop(), remove() などのメソッドと、要素を検索する index() メソッドを提供しています。C++ では、vector クラスが、push_back(), insert(), pop_back(), erase() などの同様のメソッドを提供しています。

動的配列の要素の追加、削除に必要な時間計算量を考えてみましょう。以降、動的配列の論理サイズ、容量を次のように表します。

- L : 論理サイズ
- C : 容量

### **1-1. 先頭への挿入**

動的配列の先頭に要素を挿入するには、通常、既存のすべての要素を 1 つずつずらして、新しい要素のためのスペースを確保する必要があります。これは特に配列が大きい場合には、時間のかかる操作となります。n 個の要素がある場合、n 個の要素を移動させる必要があるため、結果として O(n) の計算コストが必要になります。動的配列の一番最初の要素にいきなり値を追加できないのは、すでにセルの中に値が存在していており、値を上書きしてしまうからです。

**Note: イメージ**

```php
// [32,34,23,3,10]、L=5, C=10 に 20 を先頭に挿入します
[32,34,23,3,10,null,null,null,null,null]
[32,34,23,3,10,20] // L=6、C=10、O(1)
[32,34,23,3,20,10] // L=6、C=10、O(1)
[32,34,23,20,3,10] // L=6、C=10、O(1)
[32,34,20,23,3,10] // L=6、C=10、O(1)
[32,20,34,23,3,10] // L=6、C=10、O(1)
[20,32,34,23,3,10] // L=6、C=10、O(1)
```

**Note: 値のコピー**

スロットに値をコピーするとは、メモリの中にあるセルの中に、値をコピーし格納することを指します。例えば、JavaScript では以下のような処理が行われています。

```php
let copyValue = array[1];
array[1] = array[0];
array[0] = copyValue;
```

要素を 1 つ隣に移動するのに 3 回の計算が必要となるので、n 個の要素を移動するには 3n (= O(n)) 回の計算が必要になります。

### **1-2. 先頭の削除**

一方、先頭の要素を削除する場合は、n-1 個の要素を 1 スロット後ろ方向に移動させる必要があるため、O(n) の計算コストが必要になります。

**Note: イメージ**

```php
// [34,32,23,3,10]、L=5、C=10、34 を先頭から取り除きます
[32,34,23,3,10] // L=5、C=10、O(1)
[32,23,34,3,10] // L=5、C=10、O(1)
[32,23,3,34,10] // L=5、C=10、O(1)
[32,23,3,10,34] // L=5、C=10、O(1)
[32,23,3,10,null] // L=4、C=10、O(1)
```

**Note: 注意**

動的配列は、データ構造として固定長配列を使用して実装され、要素の追加や削除によって論理配列のサイズを変更する機能を提供します。しかし、この操作では、実際に固定長配列から要素を追加したり削除したりすることはありません。その代わり、必要なサイズの新しい配列を作成し、関連する要素を古い配列から新しい配列にコピーします。

動的配列に要素を追加する場合、配列の実装は通常、新しい要素を格納するのに十分な容量があるかどうかをチェックします。十分な容量がある場合は、単に配列の論理サイズを増加させ、次の使用可能なインデックスに新しい要素を格納します。もし十分な容量がない場合は、より大きな容量の新しい配列を作成し、古い要素と新しい要素を新しい配列にコピーします。

同様に、動的配列から要素を削除すると、配列の実装は単に配列の論理サイズをデクリメントし、削除された要素が残したギャップを埋めるために残りの要素を移動させることがあります。しかし、実際の要素は、その下にある固定サイズの配列から削除されるわけではありません。

### **2-1. 途中への挿入**

n 個の要素の動的配列の真ん中へ要素の挿入を行う場合、先ほど学習した先頭に要素を挿入する場合と同様の処理を配列の真ん中まで行えば良いことになります。したがって、0.5n 個の要素を移動させる必要があり、結果として O(n) の計算コストが必要になります。

**Note: イメージ**

```php
// [32,34,23,3]、L=4、C=10、20 を真ん中に挿入します
[32,34,23,3,null,null,null,null]
[32,34,23,3,20] // L=5、C=10、O(1)
[32,34,23,20,3] // L=5、C=10、O(1)
[32,34,20,23,3] // L=5、C=10、O(1)
```

### **2-2. 途中の削除**

一方、動的配列の真ん中から要素を削除する場合、0.5n - 1 回の移動が必要となるので、同様に O(n) の計算コストが必要になります。

**Note: イメージ**

```php
// [34,32,23,3,10]、L=5、C=10、23 を真ん中から取り除きます
[34,32,3,23,10] // L=5、C=10、O(1)
[34,32,3,10,23] // L=5、C=10、O(1)
[34,32,3,10,null] // L=5、C=10、O(1)
```

### **3-1. 末端への挿入**

配列の末端に要素を挿入する処理は、先述した通り、配列の論理サイズと収容可能サイズとの兼ね合いで妥当な処理が実行されます。配列の容量が最大に達している、つまり「論理サイズ = 収容可能サイズ」の場合、新しい配列を作成し、もとの配列に入っていた n 個のデータと新しく追加したデータを合わせた計 n+1 個の要素を、その新しい配列にコピーします。したがって、O(n) の計算コストが必要になります。

しかし、ほとんどのケースでは、配列に余裕があるので、最後のスロットにデータを挿入するだけで済みます。この場合は、計算コストが O(1) となります。

**Note: イメージ**

```php
[1,2,3,4,null,null,null,null] // C=8、L=4、O(1)
[1,2,3,4,5] // C=8、L=5、O(1)
[1,2,3,4,5,6] // C=8、L=6、O(1)
[1,2,3,4,5,6,7] // C=8、L=7、O(1)
[1,2,3,4,5,6,7,8] // C=8、L=8、O(1)

// C=L となったとき、それ以上要素を追加することができないので、新しい配列を作成し、そこに n+1 個の要素をコピーします
[1,2,3,4,5,6,7,8,9] // C=16、L=9、O(9)
```

このように、コンピュータは複数の要素を一気に追加することができず、ステップバイステップでしか処理を行うことができないため、時間計算量や空間計算量を常に意識する必要がある点に注意しましょう。

収容可能サイズが n の空の配列に対して、n+1 個の要素を挿入する時、最初の n 回はまだ値が入っていない部分に挿入するだけなので、それぞれ O(1) の計算コストがかかり、最後の n+1 個目の値の挿入のみ、配列の要領を超えてしまうので、新しい配列を作成し、n+1 個の要素をその配列にコピーします。ここで平均を求めると、

$$
n∗O(1)+O(n)n+1=2nn+1≒O(1)
$$

のようになります。したがって、最後に要素を挿入する操作の償却計算量は O(1) になります。この場合、1/nの確率で最悪計算量 O(n) が発生します。

### **3-2. 末端の削除**

配列の末尾から要素を削除するのは簡単で、単純に O(1) の計算量が発生します。

**Note: イメージ**

```php
[1,2,3,4,5,6,7,8] // C=16、L=8
[1,2,3,4,5,6,7,null] // C=16、L=7、O(1)
```
